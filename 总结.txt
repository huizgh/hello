基本数据类型 5种 使用typeof 判断数据类型:number, string, boolean, undefined, null

创建对象：1、字面量方式创建对象 2、new + 构造函数 3、工厂方式创建对象
对象属性的访问：1、对象+.+新属性名  2、对象["属性名"]方式,
hasOwnProperty 用以判断属性是否为对象自身或叫私有属性
构造函数 使用new + 构造函数  创建一类对象，这类对象叫做构造函数的实例
实例访问原型链属性时不需要写出完整路径，解释器会自动取得原型链上最近的属性值并返回,但是删除属性时必须写出准确的属性路径
构造函数特征：
		1. 首字母大写
		2. 使用this关键字初始化新对象
		3. 使用new关键字
		4. 不适用return关键字返回值


原型：每一个函数都有一个属性prototype，叫做原型属性，他的值是一个object对象，叫做原型对象。
原型对象特性：原型对象中的属性可以被其所属构造函数的实例共用。
	     实例自身不存在构造函数原型中的属性，而是复用器构造函数原型的。
继承：js自身没有继承特性， 需要程序员主动实现，而最常用的继承方式是基于原型的继承
    基于原型的继承原理：两个构造函数，上级构造函数的实例，赋值给下级构造函数的原型
    对象属性查找机制：首先查找自身属性，有则使用，没有则沿原型链逐级向上查找，直到查找到目标
                     属性，找不到则返回undefined。优先级逐级递减。
继承方式总结：1、基于原型的继承：将上级函数的实例赋值给下级函数的原型
		优点：下级函数实例可以复用原型链上所有原型的属性
		缺点：无法复用上级函数的私有属性创建功能，上级函数的私有属性会进入到下级函数的原型中
                修正函数原型中的constructor属性，将该属性值修改为函数自身

	     2、借用构造函数方式/伪造构造函数方式继承
		优点：可以复用上级函数代码逻辑创建私有属性，
		缺点：实例无法复用上级函数原型中的属性
	     3、组合方式继承

this关键字的用法：
this在函数执行时创建，表示持有当前函数的对象
	  1.页面事件处理函数中。this代表绑定事件的dom对象
	  2.对象内部函数类型属性，函数执行时this代表当前对象
	  3.普通函数内部 this代表window    注意 同一作用域下变量名和函数名不能相同，后声明对象会覆盖先声明的对象
	  4.构造函数中this 代表新对象  call/apply: 用于延长作用域，将函数放在指定作用域中执行

回调函数：主函数执行到某个阶段，达到某个触发条件后，继续执行的其它函数， 此类函数通常被叫做回调函数
         函数在js中属一等公民地位，函数作为另一个函数参数，传进主函数

|| && 替代简单逻辑
       当"或"左侧条件成立，右侧逻辑不会执行，而左侧是false，右侧逻辑会基础执行
       当“与”左侧成立返回右侧的值，左侧不成立返回左侧的值

事件委托：基于冒泡特性，当子节点事件触发时，上级节点相同事件也会触发。基于此特性，在处理字节点事件时，可以在上层节点绑定事件，触发事件后	，通过event.target属性可以准确的取得触发事件的具体元素，进而进行事件差异化处理。
	  优点：1.页面执行性能和页面事件数量相关，事件数量越多，性能越差。事件委托减少页面绑定事件数
                   量，提高页面性能  
	        2.当下级节点是动态的场景，使用事件委托不需要随着子节点变化，手动再次添加事s件

ajax 是一种客户端（浏览器端）和服务端通信技术，通常是页面通过脚本想服务器发送异步请求
	同步与异步
		同步类似接力比赛，一件事一件事按顺序执行。
		异步更像短跑，多个事物同时进行。彼此不会等待。	
	步骤：0、绝大多少浏览器，使用XMLHttpRequest 创建ajax 通信对象
	      1. 初始化通信对象  xhr.open("get", "ajaxTest.json", true);  get和post两种方式请求
	      2、发送请求 xhr.send();
	      3、开始接收服务端数据
	      4、数据接收完毕
	xhr.readyState: 
		new xhr()          //0
		open()               //1
		send()               //2
		接到响应         //3
		响应接收完毕//4
	xhr.status：http响应状态
	xhr.status  如果状态码是200或304通信正常

闭包：被外部函数返回，持有(使用）外部函数变量的内部函数。
	闭包的功能：可以使用函数构建独立命名空间，对内部内容进行封装和保护，配合闭包对外提供相应的访问或修改等功能，实现封装效果。
	闭包的缺点：由于外部函数内变量被闭包使用，进而直到闭包被销毁，内部变量对象一直有效，进而造成一定的空间占用。
	注意：由于闭包可能造成内存大量被占用无法释放，所以要谨慎使用闭包

匿名函数也叫拉姆达函数，此类函数执行时不需要函数名
	应用场景： 1、dom事件处理中使用匿名函数
		  2、对象内部函数类型属性值，通常使用匿名函数
	          3、函数作为参数
		  4、匿名自执行函数
		  5、函数作为返回值使用 可以使用匿名函数
匿名自执行函数的写法：1、(function(){})(实参)
		     2、(function(){}(实参))
		     3、运算符+ 函数 + ()    +、-、！

函数变量声明提升：预编译阶段，js内部完成两个件事： 函数对象创建（函数声明提升），变量初始化为undefined（变量声明提升）
	函数声明提升: 在单个文件或代码块中的js代码，在预编译阶段，创建所有函数声明对应的函数对象
	变量声明提升: 预编译阶段，将当前代码块或文件中所有的变量声明提前，并初始化成undefined

垃圾回收：1、标记清除： 首先标记全部对象，清除非当前环境占用对象上的标记，销毁不带有标记的对象 或叫 释放不带有标记对象占用的内存空间。
          2、引用计数：一个对象每增加一个引用，引用数量加1，而如果对象自身引用数量为零，在垃圾回收时，该对象会被销毁，或叫释放。
    js通常不建议程序员主动触发垃圾回收。垃圾回收时刻，所有代码是停止执行的。为了减少造成程序执行停滞，通常不见主动触发
    垃圾回收优化：针对垃圾回收时，程序停滞执行问题。优化方向主要是减少单次优化停滞时间。优化主要思路是，分批次 分优先级清理内存空间          ，减少单次垃圾回收时间。    可以将不再使用或想主动释放的变量赋值成null

